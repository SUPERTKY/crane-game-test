## 現在の「つかむ」仕組みの報告

### やっていること

現在のコードでは、爪が閉じ終わった瞬間に `tryGrab()` という関数が呼ばれます。この関数は以下の処理をしています：

1. 爪の中心と箱の距離を計算
2. 距離が `GRAB_THRESHOLD`（0.6）以内なら → **PointToPointConstraint を作成**
3. これは「アームの1点と箱の中心をバネ付きのヒモでつなぐ」ような拘束です

つまり**物理的に挟んでいるのではなく、見えない紐で接続している**状態です。「くっつけている」というご指摘の通りです。

---

### なぜこの方法にしたか

Cannon-esの仕様上、キネマティックボディ（`mass: 0`、位置を毎フレーム手動で設定するボディ）で動的ボディを「挟む」ことが非常に難しいためです。キネマティックボディは物理エンジンの力の計算に参加しないので、摩擦で箱を支える力が発生しません。

---

## 代替案

### 案A：爪を動的ボディにしてヒンジで接続する

爪の `mass` を `0` ではなく実際の質量（例えば `0.5`）に設定し、アーム本体との接続を `HingeConstraint` で行う方法です。

**仕組み：** 爪が物理エンジン上で「本当の物体」になるので、閉じる力（モーター）と摩擦で箱を挟み込めます。

**メリット：** 最もリアル。箱の重さや位置で爪が開いてしまう（つかみ損ねる）のも自然に再現される。

**デメリット：** 実装の難易度が高い。爪が暴れたり、物理的に不安定になりやすい。パラメータ調整が大変。

---

### 案B：閉じた時に箱を「アームの子オブジェクト」にする（物理を一時停止）

爪が閉じた時に箱の物理ボディを一時的に無効化し、Three.js側でアームの子にして一緒に動かす方法です。

**仕組み：** つかんでいる間は物理ではなく、見た目の親子関係で箱を運ぶ。離す時に物理を再開する。

**メリット：** 実装がシンプルで安定。箱が絶対に落ちない。

**デメリット：** 物理的なリアルさはゼロ。「くっつける」と本質的に同じ。

---

### 案C：摩擦を極端に高くして挟む（現在のキネマティック方式を改良）

爪と箱の接触マテリアルの摩擦係数を非常に高く（例えば `friction: 50`）設定し、キネマティックのまま力任せに挟む方法です。

**仕組み：** 物理エンジンの衝突と摩擦だけで箱を保持する。

**メリット：** Constraintを使わないので「くっつけ」感がない。つかみ損ねも自然に起きる。

**デメリット：** キネマティック同士の摩擦計算はCannon-esが苦手で、箱がすり抜けたり飛んだりする可能性がある。安定性に不安。

---

### 案D：案Aの簡易版（爪は動的＋モーター、ただし軽量実装）

爪を動的ボディにしつつ、現在の `clawLPivot / clawRPivot` の回転をモーターで再現する方法です。案Aのフル実装より調整項目を減らした形になります。

**メリット：** 挟む動作が物理的に正しく、クレーンゲームらしい「掴めるかどうか」の緊張感が出る。

**デメリット：** 案Aほどではないが、やはり物理の調整が必要。

---

### おすすめ

最もクレーンゲームらしい動きになるのは**案A（または案D）**です。爪が物理的に箱を挟むので、位置が悪ければ落ちるし、うまく挟めれば持ち上がるという自然な動作になります。

どの案で進めるか、ご指示いただけますか？
